\section{Mini-MAC}
\label{mini-mac}

Mini-MAC is a group-keyed lightweight variable-length truncated HMAC that
depends on a counter and on recent message history.  It does not increase
bus traffic or delay messages.  We explain Mini-MAC in three layers
of abstraction: architecture, design, and  implementation.

[I think we should redesign mini-MAC without counter truncation,
and putting XOR of counter and history before HMAC.]

\subsection{Architecture}
\label{arch}

Four core architectural elements characterize Mini-MAC:
(1)~Variable-size output to fit available space in the CAN packet.
(2)~Shared keys among groups of ECUs to avoid increasing bus traffic.
(3)~A counter to mitigate replay attacks;  also used [for no good reason]
to truncate HMAC outputs.
(4)~Message history to serve as "salt" against possible unknown precomputation attacks. 
[I dislike justifying history on basis of replay because it adds nothing over counter
in that regard.]
Elements (1) and (2) trade authentication strength for performance;  see
Section~\ref{security} for a discussion of this tradeoff.

[even if we keep the "split counter" (which I dislike), there is no need to 
refer to it as such. Simpler is to call it a counter and to derive various
bits from it.]

To avoid sending long tags using additional messages, Mini-MAC truncates the
HMAC to fit available space in the CAN frame (typically the resulting tag is
approximately four bytes).  

To avoid increasing bus traffic by separately authenticating the same message to different recipients, 
Mini-MAC uses long-term shared group keys instead of pairwise keys.  For example, in Figure~\ref{fig-key}, ECUs
2, 3, and 4 share the group key~$k_3$.
Group key distribution is possible because, at system design, the designer knows which ECUs communicate with which others. 
There is no need for a dynamic group key update capability because group membership will never change.
[Keys can be updated by a security manager as needed or desired.(?)]

Using a counter is a simple, standard, and effective way to mitigate replay attacks.  

Each ECU saves recent messages sent on the bus and XORs them into the HMAC input. 
[is this done uniformly by all, or per key group?] 
There are two reasons for this architectual element:  First, 
the history adds an unpredictable ``salt'' that might mitigate some possible
precomputation attacks.  Second, it adds protection against any transient
attacker (even one who knows the group keys) who cannot deduce enough of the 
message history.  It also adds an additional layer of protection 
beyond the counter against replay attacks [this reason is weak and perhaps should therefore be dropped].
	
	\begin{figure}
		\centering
		\includegraphics[width=\columnwidth]{figures/key_distribution.png}
		\caption{Mini-MAC key distribution.  Each group of ECUs shares an authentication key.}
		\label{fig-key}
	\end{figure}
	
\subsection{Design}
\label{design}

	\begin{figure}
		\centering
		\includegraphics[width=\columnwidth]{figures/minimac_diagram.png}
		\caption{Mini-MAC. The Mini-MAC of a message $M_n$ is a truncated HMAC of 
		the XOR of $M_n$, a counter, and the most recent $i$ messages.}
		\label{fig-minimac}
	\end{figure}

Figure~\ref{fig-minimac} shows how to compute 
$Mini\hbox{-}MAC(k,M_n,s,C,\hbox{History})$, 
where $k$ is the group key, 
$M_n$ is the current message, 
$s$ is the number of available bits in the current CAN frame, 
$C$ is the message counter, 
and $\hbox{History} = (M_{n-{\lambda}}, \ldots, M_{n-1})$ is the sequence of the most recent
$\lambda$ messages.

The Mini-MAC tag is computed as

\begin{equation}
\text{MAC}_{\text{mini}} = \hbox{trunc(}s,\text{HMAC}(k,\text{Input})),
\end{equation}

\noindent where HMAC is the underlying HMAC and $\hbox{trunc}(s,\cdot)$
extracts $s$ bits from its input.  The input to HMAC is computed as

\begin{equation}
\text{Input} = M_n \oplus C \oplus (M_{n-{\lambda}} \oplus \cdots \oplus M_{n-1}) .
\end{equation}


%\begin{equation}
%\text{For }i=1:h\text{, MAC}_\text{hist} = \text{MAC}_{\text{full}}\oplus\text{Message}_{n-i}
%\end{equation}
%
%\begin{equation}
%\text{MAC}_{\text{mini}} = \text{MAC}_{\text{full}}(l,l+s)
%\end{equation}


\subsection{Implementation}
\label{implementation}

We implemented Mini-MAC using three different component hash functions (MD5, SHA-1, and SHA-2) to compare the resulting running times.  
Each group key is 128~bits.  The $\hbox{trunc}(s,\cdot)$ function extracts the first $s$ bits of its input. [or explain the obfuscated way]
We used a X-bit counter, which ensures no repeated counter value wihtin twenty years.

For \textbf{HMAC-MD5},
we adapted Peslyak's~\cite{Peslyak} implementation of MD5~\cite{MD5} for the MSP430 platform, producing a 128-bit output. 
Despite known collision attacks on MD5~\cite{Wang-MD5}, we consider
MD5 for Mini-MAC for its very fast speed.  [the relevant attack here is known pre-image, not
collision finding.  more in security section]

For \textbf{HMAC-SHA-1},
we adapted Conte's~\cite{Conte-SHA1} SHA-1~\cite{FIPS-180-4} implementation for the MSP430 platform, producing a 160-bit output. 
As for MD5, despite known security vulnerabilities in SHA-1 \cite{Wang-SHA1}, 
we consider SHA1 as a potential candidate.

For \textbf{HMAC-SHA-2},
we also adapted Conte's~\cite{Conte-SHA256} SHA-2-256 implementation for the MSP430 platform, producing a 256-bit output. 
A member of the SHA-2 family of hash functions, SHA-2 is still in use and is recommended by NIST as a cryptographic hash function, 
though SHA-3 will soon replace it\cite{FIPS-180-4}. [check current status of NIST on SHA-2]
[why did we not test SHA-3?]