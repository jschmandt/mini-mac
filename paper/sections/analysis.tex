\section{Results and Analysis}
\label{analysis}

We analyze Mini-MAC for performance and security. 
Mini-MAC must be able to authenticate messages 
without compromising the performance of the real-time, safety-critical systems.

\subsection{Performance}
\label{performance}

Tables~\ref{tab-traffic}--\ref{tab-time} and Figures~\ref{fig-execution}--\ref{fig-code}
show the message traffic, execution time, code size, and RAM usage of our unoptimized implementations
of Mini-MAC and their underlying HMACs.  Time and space are dominated by the HMAC computation.

%Throughout, ``B''~denotes bytes, ``b''~denotes bits, and ``ms''~denotes milliseconds.

Table~\ref{tab-traffic} shows that Mini-MAC adds no additional bus traffic.
By contrast, HMAC-MD5 adds 128~bits (two CAN frames) per authentication,
due to the 128-bit tag.  Similarly, the pairwise-keyed Lin-MAC generates
two additional CAN frames per recipient ECU in each group communication.

Table~\ref{tab-time} shows the mean execution time
[add standard deviations] for each of our implementations of Mini-MAC.
Using MD5 is much faster than using SHA-1 or SHA-2.  As shown in Table~\ref{tab-overhead},
the overhead in time to compute Mini-MAC beyond HMAC is very little (approximately 0.38--0.68~ms).
Similarly, Figure~\ref{fig-execution} shows the mean execution times for Mini-MAC measured
in number of cycles on a 32~kHz clock.

Importantly, Table~\ref{tab-time} shows that only our MD5 implementtion of Mini-MAC runs fast enough to satisfy our
requirement of authenticating at least 40 messages per second (approximately
25~ms between messages).   
While highly optimized code might run faster, on the
basis of our timing measurements, we recommend implementing Mini-MAC using MD5.

Figure~\ref{fig-ram} shows the RAM usage for our implementations of Mini-MAC.
As shown in Table~\ref{tab-overhead}, the overehead in RAM usage to compute Mini-MAC
beyond HMAC is very low (about 5~bytes).

Figure~\ref{fig-code} shows the code size of our Mini-MAC implementations.
As shown in Table~\ref{tab-overhead}, the additional code size for Mini-MAC beyond
HMAC is very small (approximately 800~bytes).




%%% notes to me (ats)
%% be sure to comment on each of the issues from Section 6 (group keys, truncation, etc)

%Expected time to find a collision for tags of various lengths, 
%based on trying 40 hash computations per second. [this table based on birthday calc]
	
\subsection{Authentication Strength}
\label{security}

Mini-MAC detects spoofed messages by using a keyed HMAC.  It detects replay attacks
by incorporating a counter and recent message history into the HMAC input.  Using message
history also complicates a transcient attacker who may be unable to observe a sufficient
number of recent messages.  

The 128-bit keys are sufficiently long to withstand 
exhaustive key-search attacks.  The 64-bit counter is sufficient to prevent counter
rollover within the lifetime of the car.
With $\lambda = \hbox{?}$, the adversary must learn over 30~minutes of recent
message history.

A security-enhancing feature of the CAN bus is, ironically, its slow speed of at most
approximately 40 messages per second.  Figure~\ref{fig-msgdelay} shows a histogram of
message interarrival times that we collected from a 2010 Toyota Prius.
The slow speed of the CAN bus limits the rate at which an attacker can
inject messages into the bus.

Another defensive feature is that there is no simple fast way for an adversary to
test if a candidate tag is valid.   The only way we are aware of is to inject a message into the bus
and observe if the receiving ECU accepted the message.

Limitations imposed by Mini-MAC include its use of group keys and truncated HMAC tags.  
Using group keys means that a single compromised ECU learns all of the keys
to which groups it belongs.  We consider this limitation an acceptable design tradeoff
given that Mini-MAC does not increase bus utilization and the compromise of any critical
ECU is a devastating security failure.

One potential attack is for the adversary to inject messages into the bus with the hopes
of trying a tag that verifies correctly.  We shall call this attack the ``trial injection attack.''
A downside of this attack is that it would be easy to detect such an attack involving
many messages.

Table~\ref{tab-taglength} lists for various tag lengths~$L$
two reference times that are useful in assessing the effectiveness of this attack.
Column~X gives the expected time to find a particular tag of length~$L$ by
randomly guessing tags.
Column~Y gives the expected time to find a collision\footnote{A collision is any pair of 
different inputs that produces the same output.}
in Mini-MAC with tag length~$L$,
exploiting the Birthday Paradox.  
The times are computed assuming that the enemy is limited to trying 40 tags per second.

In Table~\ref{tab-taglength}, Column~X is the expected time for a straight-forward 
implementation of a trial injection attack to succeed.  We do not see how an adversary
could mount a more clever version of this, or any other, attack to achieve
the optimistic times given in Column~Y.  We include Column~Y simply as a
conservative reference.

For example, with a four-byte tag, the expected time for a straight-forward 
message injection attack to succeed is approximately 27.3~mins.  

Another potential attack is to observe bus traffic with the hopes of finding statistical
regularities that would significantly improve the chances of success of the aforementioned attack.
We conjecture that this attempt is unlikely to yield significant advantage, given the
strong properties of HMAC and some
desirable (albeit imperfect) characteristics of the component hash functions.

Given that the CAN bus does not authenticate messages, we conclude that Mini-MAC
meaningfully raises the bar of vehicular security.

	\fontfamily{ptm}\selectfont
	\begin{figure}
		\centering
		\includegraphics[width=\columnwidth]{figures/pdf.png}
		\caption{{\fontfamily{ptm}\selectfont Histogram 
		of message interarrival times observed by the authors from 
		15,768 messages on a 2010 Toyota Prius. }}
		\label{fig-msgdelay}
	\end{figure}
	
